"use strict";(self.webpackChunklibs_documentations=self.webpackChunklibs_documentations||[]).push([[681],{9613:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2391:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(9496),o=n(5924),r="tabItem_C2GR";function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r,i),hidden:n},t)}},9347:function(e,t,n){n.d(t,{Z:function(){return d}});var a=n(2081),o=n(9496),r=n(5924),i=n(1296),l=n(2024),s=n(5065),p=n(5271),m="tabList_LTMs",c="tabItem_Q2DR";function u(e){var t,n,i=e.lazy,u=e.block,d=e.defaultValue,h=e.values,g=e.groupId,b=e.className,k=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=h?h:k.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),v=(0,l.l)(f,(function(e,t){return e.value===t.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var N=null===d?d:null!=(t=null!=d?d:null==(n=k.find((function(e){return e.props.default})))?void 0:n.props.value)?t:k[0].props.value;if(null!==N&&!f.some((function(e){return e.value===N})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+N+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,s.U)(),w=y.tabGroupChoices,C=y.setTabGroupChoices,T=(0,o.useState)(N),x=T[0],E=T[1],R=[],Z=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=g){var O=w[g];null!=O&&O!==x&&f.some((function(e){return e.value===O}))&&E(O)}var j=function(e){var t=e.currentTarget,n=R.indexOf(t),a=f[n].value;a!==x&&(Z(t),E(a),null!=g&&C(g,String(a)))},I=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,o=R.indexOf(e.currentTarget)+1;n=null!=(a=R[o])?a:R[0];break;case"ArrowLeft":var r,i=R.indexOf(e.currentTarget)-1;n=null!=(r=R[i])?r:R[R.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,r.Z)("tabs-container",m)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":u},b)},f.map((function(e){var t=e.value,n=e.label,i=e.attributes;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:function(e){return R.push(e)},onKeyDown:I,onFocus:j,onClick:j},i,{className:(0,r.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":x===t})}),null!=n?n:t)}))),i?(0,o.cloneElement)(k.filter((function(e){return e.props.value===x}))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},k.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==x})}))))}function d(e){var t=(0,i.Z)();return o.createElement(u,(0,a.Z)({key:String(t)},e))}},182:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return m},default:function(){return g},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return d}});var a=n(2081),o=n(4604),r=(n(9496),n(9613)),i=n(9347),l=n(2391),s=["components"],p={id:"first-scene",title:"Our first scene",sidebar_label:"Our first scene"},m=void 0,c={unversionedId:"first-scene",id:"first-scene",title:"Our first scene",description:"This basic tutorial will help us setup our first Angular Three scene and introduce us to its core concepts.",source:"@site/docs/first-scene.mdx",sourceDirName:".",slug:"/first-scene",permalink:"/docs/first-scene",draft:!1,editUrl:"https://github.com/nartc/angular-three/tree/main/libs/documentations/docs/docs/first-scene.mdx",tags:[],version:"current",frontMatter:{id:"first-scene",title:"Our first scene",sidebar_label:"Our first scene"},sidebar:"docs",previous:{title:"Migrate to v5",permalink:"/docs/getting-started/migrate-to-v5"},next:{title:"Inputs",permalink:"/docs/core/inputs"}},u={},d=[{value:"TLDR;",id:"tldr",level:2},{value:"Setting up the Canvas",id:"setting-up-the-canvas",level:2},{value:"Adding a Mesh",id:"adding-a-mesh",level:2},{value:"Animate the cube",id:"animate-the-cube",level:2},{value:"Making our cube an Angular component",id:"making-our-cube-an-angular-component",level:2},{value:"Adding component states",id:"adding-component-states",level:2},{value:"Adding lights",id:"adding-lights",level:2},{value:"Taking control of the camera",id:"taking-control-of-the-camera",level:2},{value:"Exercise",id:"exercise",level:2}],h={toc:d};function g(e){var t,n=e.components,p=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},h,p,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This basic tutorial will help us setup our first Angular Three scene and introduce us to its core concepts."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This tutorial assumes basic knowledge of ",(0,r.kt)("a",{parentName:"p",href:"https://angular.io"},"Angular")," and ",(0,r.kt)("a",{parentName:"p",href:"https://threejs.org"},"THREE.js"))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This tutorial uses Angular Standalone APIs available since Angular 14")),(0,r.kt)("h2",{id:"tldr"},"TLDR;"),(0,r.kt)("p",null,"The tutorial is a bit long so here's the TLDR; version for folks that want to get straight to the code."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We set up a Canvas with ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-canvas>")," which is the entry point to our NGT scene graph"),(0,r.kt)("li",{parentName:"ul"},"We use ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-mesh>")," along with ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-box-geometry>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-mesh-standard-material>")," to construct a cube then animate it"),(0,r.kt)("li",{parentName:"ul"},"We separate our ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-mesh>"),", along with its internal states, into a reusable Angular component so we can have more than one cube"),(0,r.kt)("li",{parentName:"ul"},"We set up some lighting to make our cubes more dynamic"),(0,r.kt)("li",{parentName:"ul"},"We introduce ",(0,r.kt)("inlineCode",{parentName:"li"},"@angular-three/soba")," library and add the ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-soba-orbit-controls>")," to take controls of the Camera")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"appComponentHtml",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas>\n  <ngt-ambient-light intensity="0.5"></ngt-ambient-light>\n  <ngt-spot-light [position]="10" angle="0.15" penumbra="1"></ngt-spot-light>\n  <ngt-point-light [position]="-10"></ngt-point-light>\n\n  <app-cube [position]="[1.2, 0, 0]"></app-cube>\n  <app-cube [position]="[-1.2, 0, 0]"></app-cube>\n\n  <ngt-soba-orbit-controls></ngt-soba-orbit-controls>\n</ngt-canvas>\n'))),(0,r.kt)(l.Z,{value:"appComponentTs",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  selector: 'app-root',\n  standalone: true,\n  templateUrl: './app.component.html',\n  imports: [NgtCanvas, NgtAmbientLight, NgtSpotLight, NgtPointLight, NgtSobaOrbitControls, CubeComponent],\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent {}\n"))),(0,r.kt)(l.Z,{value:"cubeComponentHtml",label:"cube.component.html",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh\n  (beforeRender)="onCubeBeforeRender($event)"\n  (click)="active = !active"\n  (pointerover)="hovered = true"\n  (pointerout)="hovered = false"\n  [scale]="active ? 1.5 : 1"\n  [position]="position"\n>\n  <ngt-box-geometry></ngt-box-geometry>\n  <ngt-mesh-standard-material [color]="hovered ? \'turquoise\' : \'tomato\'"></ngt-mesh-standard-material>\n</ngt-mesh>\n'))),(0,r.kt)(l.Z,{value:"cubeComponentTs",label:"cube.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  selector: 'app-cube',\n  standalone: true,\n  templateUrl: 'cube.component.html',\n  imports: [NgtMesh, NgtBoxGeometry, NgtMeshStandardMaterial],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CubeComponent {\n  @Input() position?: NgtVector3;\n\n  hovered = false;\n  active = false;\n\n  onCubeBeforeRender($event: { state: NgtRenderState; object: Mesh }) {\n    const cube = $event.object;\n    cube.rotation.x += 0.01;\n  }\n}\n"))),(0,r.kt)(l.Z,{value:"styles",label:"styles.css",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"/* You can add global styles to this file, and also import other style files */\n\nhtml,\nbody {\n  font-family: sans-serif;\n  height: 100%;\n  width: 100%;\n  margin: 0;\n}\n")))),(0,r.kt)("h2",{id:"setting-up-the-canvas"},"Setting up the Canvas"),(0,r.kt)("p",null,"The scene graph in NGT starts with the ",(0,r.kt)("inlineCode",{parentName:"p"},"CanvasComponent"),". Let's start by putting ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-canvas>")," on our ",(0,r.kt)("inlineCode",{parentName:"p"},"app.component.html"),", and import ",(0,r.kt)("inlineCode",{parentName:"p"},"NgtCanvas")," in our ",(0,r.kt)("inlineCode",{parentName:"p"},"app.component.ts")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"html",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"// highlight-start\n<ngt-canvas></ngt-canvas>\n// highlight-end\n"))),(0,r.kt)(l.Z,{value:"component",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\n//          \ud83d\udc47 Standalone component NgtCanvas\nimport { NgtCanvas } from '@angular-three/core';\n// highlight-end\n\n@Component({\n  /* ... */\n  standalone: true,\n  imports: [\n    /* ... */\n    // highlight-start\n    NgtCanvas,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ngt-canvas")," sets up the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"WebGLRenderer"),", a default ",(0,r.kt)("inlineCode",{parentName:"li"},"Scene"),", and a default ",(0,r.kt)("inlineCode",{parentName:"li"},"Camera")," which are the basic building blocks for any THREE scene graph."),(0,r.kt)("li",{parentName:"ul"},"A render loop that renders our scene every frame"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"window:resize")," listener that updates our Renderer and Camera when the viewport is resized. The listener will automatically get cleaned up when the ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-canvas>")," component is destroyed")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-canvas>")," is responsive to fit the parent element dimension so we can control how big or small our 3D scene is by adjusting the width and height of the parent element."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-html"},'\x3c!--        \ud83d\udc47 we can CSS this class to control the size as well as the position of our Scene --\x3e\n<div class="canvas-container">\n  <ngt-canvas></ngt-canvas>\n</div>\n'))),(0,r.kt)("p",null,"Next, let's adjust our global ",(0,r.kt)("inlineCode",{parentName:"p"},"styles.css")," a bit to make the viewport 100% width and height."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"styles",label:"styles.css",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"html,\nbody {\n  height: 100%;\n  width: 100%;\n  margin: 0;\n}\n")))),(0,r.kt)("h2",{id:"adding-a-mesh"},"Adding a Mesh"),(0,r.kt)("p",null,"Our scene is empty at the moment. Let's fill it with our first THREE Object3D by rendering a ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh>")," component, which wraps ",(0,r.kt)("inlineCode",{parentName:"p"},"THREE.Mesh"),"."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"html",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<ngt-canvas>\n  // highlight-start\n  \x3c!-- \ud83d\udc47 renders the Mesh --\x3e\n  <ngt-mesh></ngt-mesh>\n  // highlight-end\n</ngt-canvas>\n"))),(0,r.kt)(l.Z,{value:"component",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { NgtCanvas } from '@angular-three/core';\n// highlight-start\n//          \ud83d\udc47 Standalone component NgtMesh\nimport { NgtMesh } from '@angular-three/core/meshes';\n// highlight-end\n\n@Component({\n  /* ... */\n  standalone: true,\n  imports: [\n    /* ... */\n    NgtCanvas,\n    // highlight-start\n    NgtMesh,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"THREE.Mesh")," is the one of the most fundamental objects in THREE.js, and it is used to hold a ",(0,r.kt)("strong",{parentName:"p"},"Geometry")," and a ",(0,r.kt)("strong",{parentName:"p"},"Material")," needed to represent a shape in the 3D space. We'll use ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-box-geometry>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh-basic-material>")," to create a cube."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"html",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<ngt-canvas>\n  <ngt-mesh>\n    // highlight-start\n    <ngt-box-geometry></ngt-box-geometry>\n    <ngt-mesh-basic-material></ngt-mesh-basic-material>\n    // highlight-end\n  </ngt-mesh>\n</ngt-canvas>\n"))),(0,r.kt)(l.Z,{value:"component",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { NgtCanvas } from '@angular-three/core';\nimport { NgtMesh } from '@angular-three/core/meshes';\n// highlight-start\nimport { NgtBoxGeometry } from '@angular-three/core/geometries';\nimport { NgtMeshBasicMaterial } from '@angular-three/core/materials';\n// highlight-end\n\n@Component({\n  /* ... */\n  standalone: true,\n  imports: [\n    /* ... */\n    NgtCanvas,\n    NgtMesh,\n    // highlight-start\n    NgtBoxGeometry,\n    NgtMeshBasicMaterial,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("p",null,"At this point, we have something on the scene that we can check out"),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/distracted-cherry-3zxs6n?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2Fapp.component.html&theme=dark&view=preview",title:"first-scene-first-cube",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("h2",{id:"animate-the-cube"},"Animate the cube"),(0,r.kt)("p",null,"3D scene is boring without any animation. Animation in THREE.js works in a simple manner. We are rendering our scene every frame so to animate an object, we can ",(0,r.kt)("em",{parentName:"p"},"move")," that object little by little ",(0,r.kt)("em",{parentName:"p"},"before")," every render. In NGT, all objects have a ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)")," Output that we can listen and run some logic before the scene is rendered. Let's use ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)")," to animate our cube"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"html",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas>\n  \x3c!--                        \ud83d\udc47 we are handling this in our component class --\x3e\n  <ngt-mesh (beforeRender)="onCubeBeforeRender($event)">\n    <ngt-box-geometry></ngt-box-geometry>\n    <ngt-mesh-basic-material></ngt-mesh-basic-material>\n  </ngt-mesh>\n</ngt-canvas>\n'))),(0,r.kt)(l.Z,{value:"ts",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { NgtRenderState } from '@angular-three/core';\nimport { Mesh } from 'three';\n\n@Component({\n  /* ... */\n  standalone: true,\n  template: 'app.component.html',\n  imports: [\n    /*...*/\n  ],\n  /* ... */\n})\nexport class AppComponent {\n  onCubeBeforeRender($event: { state: NgtRenderState; object: Mesh }) {\n    const cube = $event.object;\n    // we are rotating our cube little by little before it gets rendered\n    cube.rotation.x += 0.01;\n  }\n}\n")))),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/first-scene-first-cube-animated-2tegkl?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2Fapp.component.html&theme=dark&view=preview",title:"first-scene-first-cube-animated",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(beforeRender)")," is invoked outside of Angular Zone to maintain the performance. Please try ",(0,r.kt)("strong",{parentName:"li"},"NOT")," to update any component state in ",(0,r.kt)("inlineCode",{parentName:"li"},"beforeRender")," handler"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$event.state")," is the object that holds the current information about the Canvas: viewport, mouse position, clock, delta etc..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$event.object")," is the Object3D that is being handled in this particular ",(0,r.kt)("inlineCode",{parentName:"li"},"beforeRender")," callback."))),(0,r.kt)("p",null,"That was easy! Before we move on, let's pause for a moment to understand what is happening here."),(0,r.kt)("p",null,"Minus all the module imports, our scene is about 6 lines of code + 3 lines of ",(0,r.kt)("inlineCode",{parentName:"p"},"onCubeBeforeRender")," for animation. Here's the equivalence in vanilla THREE.js code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, document.clientWidth / document.clientHeight, 0.1, 1000);\n\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(document.clientWidth, document.clientHeight);\ndocument.querySelector('app-root').appendChild(renderer.domElement);\n\n/**\n * code to handle window:resize goes here\n */\n\nconst cube = new THREE.Mesh();\ncube.geometry = new THREE.BoxGeometry();\ncube.material = new THREE.MeshBasicMaterial();\n\nscene.add(cube);\n\nfunction animate() {\n  requestAnimationFrame(animate);\n  cube.rotation.x += 0.01;\n  renderer.render(scene, camera);\n}\n\nanimate();\n")),(0,r.kt)("p",null,"Vanilla THREE.js does not look so bad either. However, by leveraging Angular template, we are able to express our Scene in a declarative way. We can use Angular template expression like ",(0,r.kt)("inlineCode",{parentName:"p"},"*ngIf")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"*ngFor")," to allow our scene to be more dynamic. In addition, the objects on our scene are also aware of their life-cycles which means they can clean themselves up when they are ",(0,r.kt)("em",{parentName:"p"},"destroyed"),"."),(0,r.kt)("p",null,"Next section of the tutorial will show even a ",(0,r.kt)("em",{parentName:"p"},"better")," reason to use NGT. Let's continue"),(0,r.kt)("h2",{id:"making-our-cube-an-angular-component"},"Making our cube an Angular component"),(0,r.kt)("p",null,"What is better than one cube? TWO cubes! Let's start by making our cube an Angular component"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"cubeHtml",label:"cube.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh (beforeRender)="onCubeBeforeRender($event)">\n  <ngt-box-geometry></ngt-box-geometry>\n  <ngt-mesh-basic-material></ngt-mesh-basic-material>\n</ngt-mesh>\n'))),(0,r.kt)(l.Z,{value:"cubeTs",label:"cube.component.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  selector: 'app-cube',\n  standalone: true,\n  templateUrl: 'cube.component.html',\n  imports: [NgtMesh, NgtMeshBasicMaterial, NgtBoxGeometry],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CubeComponent {\n  // \ud83d\udc47 copy from AppComponent\n  onCubeBeforeRender($event: { state: NgtRenderState; object: Mesh }) {\n    const cube = $event.object;\n    cube.rotation.x += 0.01;\n  }\n}\n"))),(0,r.kt)(l.Z,{value:"appHtml",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<ngt-canvas>\n  <app-cube></app-cube>\n</ngt-canvas>\n"))),(0,r.kt)(l.Z,{value:"appTs",label:"app.component.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  /* ... */\n  standalone: true,\n  template: 'app.component.html',\n  imports: [\n    NgtCanvas,\n    // highlight-start\n    CubeComponent,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("p",null,"Everything works the same as before but now we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"CubeComponent")," that we can add states to to customize our cube."),(0,r.kt)("h2",{id:"adding-component-states"},"Adding component states"),(0,r.kt)("p",null,"We will add two states: ",(0,r.kt)("inlineCode",{parentName:"p"},"hovered")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"active")," to our ",(0,r.kt)("inlineCode",{parentName:"p"},"CubeComponent")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When we hover over our cube, we set ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," and vice versa"),(0,r.kt)("li",{parentName:"ul"},"When we click on our cube, we toggle the ",(0,r.kt)("inlineCode",{parentName:"li"},"active")," state"),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"active"),", the cube is 1.5 times bigger using ",(0,r.kt)("inlineCode",{parentName:"li"},"[scale]")),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered"),", the cube has turquoise color and tomato color when not ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered"),".")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"cubeHtml",label:"cube.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh\n    (beforeRender)="onCubeBeforeRender($event)"\n    // highlight-start\n    (click)="active = !active"\n    (pointerover)="hovered = true"\n    (pointerout)="hovered = false"\n    [scale]="active ? 1.5 : 1"\n    // highlight-end\n>\n    <ngt-box-geometry></ngt-box-geometry>\n    <ngt-mesh-basic-material\n        // highlight-start\n        [color]="hovered ? \'turquoise\' : \'tomato\'"\n        // highlight-end\n    ></ngt-mesh-basic-material>\n</ngt-mesh>\n'))),(0,r.kt)(l.Z,{value:"cubeTs",label:"cube.component.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  selector: 'app-cube',\n  standalone: true,\n  templateUrl: 'cube.component.html',\n  imports: [\n    /* ... */\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class CubeComponent {\n  // highlight-start\n  hovered = false;\n  active = false;\n  // highlight-end\n\n  onCubeBeforeRender($event: { state: NgtRenderState; object: Mesh }) {\n    const cube = $event.object;\n    cube.rotation.x += 0.01;\n  }\n}\n")))),(0,r.kt)("p",null,"Interact with the cube and see the magic \ud83e\udd2f"),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/first-scene-first-cube-component-nsfx98?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fapp%2Fcube.component.html&theme=dark&view=preview",title:"first-scene-first-cube-component",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(click)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"(pointerover)"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"(pointerout)")," look like DOM events but they are not. They are named as such to give a sense of familiarity to improve Developer Experience (DX)."),(0,r.kt)("li",{parentName:"ul"},"These events get back into Angular Zone so that triggering these events can update Component's state (eg: ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"active"),") and trigger Change Detection cycles. Normally, NGT bails out of Angular Zone to maintain the framerate.")),(0,r.kt)("p",null,"Now that our cube is interactive and fun, we can render another cube so we can double the fun. But first, we need to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"position")," Input to our ",(0,r.kt)("inlineCode",{parentName:"p"},"CubeComponent"),". This allows us to position our ",(0,r.kt)("inlineCode",{parentName:"p"},"CubeComponent")," in different positions so we can see them all on the scene."),(0,r.kt)("p",null,"Good. Now we can update our ",(0,r.kt)("inlineCode",{parentName:"p"},"app.component.html")," to render another cube"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"appHtml",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas>\n  \x3c!--                    \ud83d\udc47 move this cube 1.2 unit to the right --\x3e\n  <app-cube [position]="[1.2, 0, 0]"></app-cube>\n  \x3c!--                    \ud83d\udc47 move this cube 1.2 unit to the left --\x3e\n  <app-cube [position]="[-1.2, 0, 0]"></app-cube>\n</ngt-canvas>\n'))),(0,r.kt)(l.Z,{value:"cubeTs",label:"cube.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"export class CubeComponent implements OnInit {\n+ @Input('position') position?: NgtVector3;\n  hovered = false;\n  active = false;\n\n  onCubeBeforeRender($event: {state: NgtRenderState, object: Mesh}) {\n    const cube = $event.object;\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.005\n  }\n}\n"))),(0,r.kt)(l.Z,((t={value:"cubeHtml"}).value="cube.component.html",t.mdxType="TabItem",t),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},'<ngt-mesh\n    (beforeRender)="onCubeBeforeRender($event)"\n    (click)="active = !active"\n    (pointerover)="hovered = true"\n    (pointerout)="hovered = false"\n    [scale]="active ? 1.5 : 1"\n+   [position]="position"\n>\n    <ngt-box-geometry></ngt-box-geometry>\n    <ngt-mesh-basic-material\n        [color]="hovered ? \'turquoise\' : \'tomato\'">\n    </ngt-mesh-basic-material>\n</ngt-mesh>\n')))),(0,r.kt)("p",null,"and voila!"),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/first-scene-first-cube-two-cubes-ytbh3o?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"first-scene-first-cube-two-cubes",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("h2",{id:"adding-lights"},"Adding lights"),(0,r.kt)("p",null,"Our cubes are animated and reactive. But they look bland. They don't even look like cubes at the moment. It is because they lack Light Reflection."),(0,r.kt)("p",null,"First, let's switch out ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh-basic-material>")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh-standard-material>")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"cubeHtml",label:"cube.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"<ngt-mesh>\n    <ngt-box-geometry></ngt-box-geometry>\n-   <ngt-mesh-basic-material></ngt-mesh-basic-material>\n+   <ngt-mesh-standard-material></ngt-mesh-standard-material>\n</ngt-mesh>\n"))),(0,r.kt)(l.Z,{value:"cubeTs",label:"cube.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"@Component({\n    /* ... */\n    imports: [\n        /* ... */\n        NgtMesh,\n        NgtBoxGeometry,\n-       NgtMeshBasicMaterial,\n+       NgtMeshStandardMaterial,\n    ],\n    /* ... */\n})\nexport class CubeComponent {}\n")))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We can check it out now and notice that our cubes are pitch black. This is because ",(0,r.kt)("inlineCode",{parentName:"p"},"MeshStandardMaterial"),' is a material that needs to be lit up by lights. Imagine a dark room with no lights, any object would be black. Our scene background just happens to be "white" by default.')),(0,r.kt)("p",null,"Next, let's start adding lights. We'll use ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-ambient-light>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-spot-light>"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-point-light>")),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"appHtml",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas>\n  // highlight-start\n  <ngt-ambient-light intensity="0.5"></ngt-ambient-light>\n  <ngt-spot-light [position]="10" angle="0.15" penumbra="1"></ngt-spot-light>\n  <ngt-point-light [position]="-10"></ngt-point-light>\n  // highlight-end\n\n  <app-cube [position]="[1.2, 0, 0]"></app-cube>\n  <app-cube [position]="[-1.2, 0, 0]"></app-cube>\n</ngt-canvas>\n'))),(0,r.kt)(l.Z,{value:"component",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nimport { NgtAmbientLight, NgtSpotLight, NgtPointLight } from '@angular-three/core/lights';\n// highlight-end\n\n@Component({\n  /* ... */\n  standalone: true,\n  imports: [\n    /* ... */\n    NgtCanvas,\n    // highlight-start\n    NgtAmbientLight,\n    NgtSpotLight,\n    NgtPointLight,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("p",null,"Our cubes look so much better now, with dimensionality, showing that they are real 3D objects."),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/first-scene-first-cube-lights-ntifzu?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"first-scene-first-cube-lights",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("h2",{id:"taking-control-of-the-camera"},"Taking control of the camera"),(0,r.kt)("p",null,"Who hasn't tried to \"grab\" the scene and move it around? We cannot do that yet as our Camera is static in its position. Let's take over the Camera with ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-soba-orbit-controls>"),". To do that, we need to install another NGT library ",(0,r.kt)("inlineCode",{parentName:"p"},"@angular-three/soba")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"soba"),' is a Vietnamese word ("S\u1ed1 Ba") and it literally means "Number 3" (as in THREEE.js)')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"npm install @angular-three/soba\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@angular-three/soba")," is a collection of utilities ported from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pmndrs/drei"},"React Three Drei")," that makes it easier to work with 3D scenes. One of those utilities is ",(0,r.kt)("inlineCode",{parentName:"p"},"OrbitControls")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"All utilities exported from ",(0,r.kt)("inlineCode",{parentName:"p"},"@angular-three/soba")," are prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"ngt-soba"))),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"appHtml",label:"app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas>\n  <ngt-ambient-light intensity="0.5"></ngt-ambient-light>\n  <ngt-spot-light [position]="10" angle="0.15" penumbra="1"></ngt-spot-light>\n  <ngt-point-light [position]="-10"></ngt-point-light>\n\n  <app-cube [position]="[1.2, 0, 0]"></app-cube>\n  <app-cube [position]="[-1.2, 0, 0]"></app-cube>\n\n  // highlight-start\n  <ngt-soba-orbit-controls></ngt-soba-orbit-controls>\n  // highlight-end\n</ngt-canvas>\n'))),(0,r.kt)(l.Z,{value:"component",label:"app.component.ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nimport { NgtSobaOrbitControls } from '@angular-three/soba/controls';\n// highlight-end\n\n@Component({\n  /* ... */\n  imports: [\n    /* ... */\n    NgtCanvas,\n    NgtAmbientLight,\n    NgtSpotLight,\n    NgtPointLight,\n    // highlight-start\n    NgtSobaOrbitControls,\n    // highlight-end\n  ],\n  /* ... */\n})\nexport class AppComponent {}\n")))),(0,r.kt)("iframe",{class:"code-demo",src:"https://codesandbox.io/embed/first-scene-first-cube-controls-kz16d9?fontsize=14&hidenavigation=1&theme=dark&view=preview",title:"first-scene-first-cube-controls",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.kt)("p",null,"and that concludes our first tutorial. That was fun!"),(0,r.kt)("h2",{id:"exercise"},"Exercise"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Try playing with the colors"),(0,r.kt)("li",{parentName:"ul"},"Try using a different Geometry to display something other than a cube"),(0,r.kt)("li",{parentName:"ul"},"Try placing more objects using different positions"),(0,r.kt)("li",{parentName:"ul"},"Try different lights")))}g.isMDXComponent=!0}}]);