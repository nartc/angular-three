"use strict";(self.webpackChunklibs_documentations=self.webpackChunklibs_documentations||[]).push([[976],{9613:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(n),h=r,u=m["".concat(s,".").concat(h)]||m[h]||c[h]||i;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},943:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return c}});var a=n(2081),r=n(4604),i=(n(9496),n(9613)),o=["components"],l={id:"body",title:"Body",sidebar_label:"Body"},s=void 0,d={unversionedId:"cannon/body",id:"cannon/body",title:"Body",description:"To interact with Cannon Body API, we use NgtPhysicBody service from @angular-three/cannon",source:"@site/docs/cannon/body.mdx",sourceDirName:"cannon",slug:"/cannon/body",permalink:"/docs/cannon/body",draft:!1,editUrl:"https://github.com/nartc/angular-three/tree/main/libs/documentations/docs/docs/cannon/body.mdx",tags:[],version:"current",frontMatter:{id:"body",title:"Body",sidebar_label:"Body"},sidebar:"docs",previous:{title:"Physics",permalink:"/docs/cannon/physics"},next:{title:"Constraint",permalink:"/docs/cannon/constraint"}},p={},c=[{value:"Usage",id:"usage",level:2},{value:"Body Creators",id:"body-creators",level:2},{value:"<code>useOnTemplate</code>",id:"useontemplate",level:2},{value:"<code>ref</code>",id:"ref",level:2},{value:"Types",id:"types",level:2}],m={toc:c};function h(e){var t=e.components,l=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To interact with ",(0,i.kt)("a",{parentName:"p",href:"https://pmndrs.github.io/cannon-es/docs/classes/Body.html"},"Cannon Body API"),", we use ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtPhysicBody")," service from ",(0,i.kt)("inlineCode",{parentName:"p"},"@angular-three/cannon")),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  providers: [NgtPhysicBody],\n})\nexport class FloorComponent {\n  // \ud83d\udc47 now we can use this ref on the template\n  planeRef = this.physicBody.usePlane(/* ... */);\n\n  constructor(private physicBody: NgtPhysicBody) {}\n}\n")),(0,i.kt)("h2",{id:"body-creators"},"Body Creators"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"name"),(0,i.kt)("th",{parentName:"tr",align:null},"props"),(0,i.kt)("th",{parentName:"tr",align:null},"description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"usePlane"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"PlaneProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Plane")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useBox"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BoxProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Box")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useCylinder"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CylinderProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Cylinder")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useHeightfield"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HeightfieldProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Heightfield")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useParticle"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ParticleProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Particle")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useSphere"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SphereProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Sphere")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useTrimesh"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TrimeshProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"Trimesh")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useConvexPolyhedron"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ConvexPolyhedronProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"ConvexPolyhedron")," to the Physic World")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"useCompoundBody"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CompoundBodyProps")),(0,i.kt)("td",{parentName:"tr",align:null},"Add a ",(0,i.kt)("inlineCode",{parentName:"td"},"CompoundBody")," to the Physic World")))),(0,i.kt)("p",null,"All Body Creators return ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtPhysicBodyReturn")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export interface NgtPhysicBodyReturn {\n  ref: Ref<THREE.Object3D>;\n  api: NgtPhysicsBodyPublicApi;\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ref")," is used to pass in an ",(0,i.kt)("inlineCode",{parentName:"li"},"NgtInstance")," ",(0,i.kt)("inlineCode",{parentName:"li"},"[ref]")," Input"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"api")," is to interact with the Physic World like updating ",(0,i.kt)("inlineCode",{parentName:"li"},"position"),", applying forces etc...")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n  selector: \'sandbox-box\',\n  standalone: true,\n  template: `\n    <ngt-mesh\n      [ref]="boxRef.ref"\n      [castShadow]="true"\n      [receiveShadow]="true"\n      (beforeRender)="onBoxBeforeRender($event.state)"\n    >\n      <ngt-box-geometry [args]="boxSize"></ngt-box-geometry>\n      <ngt-mesh-lambert-material></ngt-mesh-lambert-material>\n    </ngt-mesh>\n  `,\n  imports: [NgtMesh, NgtBoxGeometry, NgtMeshLambertMaterial],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [NgtPhysicBody],\n})\nexport class BoxComponent {\n  boxSize: NgtTriple = [4, 4, 4];\n\n  boxRef = this.physicBody.useBox(() => ({\n    mass: 1,\n    type: \'Kinematic\',\n    args: this.boxSize,\n  }));\n\n  constructor(private physicBody: NgtPhysicBody) {}\n\n  onBoxBeforeRender({ clock }: NgtRenderState) {\n    const t = clock.getElapsedTime();\n    // highlight-start\n    this.boxRef.api.position.set(Math.sin(t * 2) * 5, Math.cos(t * 2) * 5, 3);\n    this.boxRef.api.rotation.set(Math.sin(t * 6), Math.cos(t * 6), 0);\n    // highlight-end\n  }\n}\n')),(0,i.kt)("h2",{id:"useontemplate"},(0,i.kt)("inlineCode",{parentName:"h2"},"useOnTemplate")),(0,i.kt)("p",null,"All body creators accept an optional second argument ",(0,i.kt)("inlineCode",{parentName:"p"},"useOnTemplate"),". This flag is defaulted to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," which means that ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtPhysicBody")," expects us to pass the returned ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," into some ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtObject")),(0,i.kt)("p",null,"However, there are cases where we would want to still constraint some object in the physic world without giving it a representation in the 3D scene. Setting ",(0,i.kt)("inlineCode",{parentName:"p"},"useOnTemplate = false")," allows us to do that as ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtPhysicBody")," will create a blank ",(0,i.kt)("inlineCode",{parentName:"p"},"THREE.Object3D")," to give it physic constraints."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n  selector: \'sandbox-lamp\',\n  standalone: true,\n  template: `\n    <ngt-mesh sandboxDragConstraint [ref]="lampRef.ref" [position]="[0, 16, 0]">\n      <ngt-cone-geometry [args]="[2, 2.5, 32]"></ngt-cone-geometry>\n      <ngt-mesh-standard-material></ngt-mesh-standard-material>\n      <ngt-point-light [intensity]="10" [distance]="5"></ngt-point-light>\n      <ngt-spot-light\n        [position]="[0, 20, 0]"\n        [angle]="0.4"\n        [penumbra]="1"\n        [intensity]="0.6"\n        castShadow\n      ></ngt-spot-light>\n    </ngt-mesh>\n  `,\n  imports: [NgtMesh, NgtConeGeometry, NgtMeshStandardMaterial, NgtPointLight, NgtSpotLight],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [NgtPhysicBody, NgtPhysicConstraint],\n})\nexport class SandboxLampComponent implements OnInit {\n  // highlight-start\n  fixtureRef = this.physicBody.useSphere(\n    () => ({\n      args: [1],\n      position: [0, 16, 0],\n      type: \'Static\',\n    }),\n    false\n  );\n  // highlight-end\n  lampRef = this.physicBody.useBox(() => ({\n    angulardamping: 1.99,\n    args: [1, 0, 5],\n    linearDamping: 0.9,\n    mass: 1,\n    position: [0, 16, 0],\n  }));\n\n  constructor(private physicBody: NgtPhysicBody, private physicConstraint: NgtPhysicConstraint) {}\n\n  ngOnInit() {\n    // highlight-start\n    this.physicConstraint.usePointToPointConstraint(this.fixtureRef.ref, this.lampRef.ref, {\n      pivotA: [0, 0, 0],\n      pivotB: [0, 2, 0],\n    });\n    // highlight-end\n  }\n}\n')),(0,i.kt)("p",null,"The above example shows that we create a ",(0,i.kt)("inlineCode",{parentName:"p"},"fixture")," as an ",(0,i.kt)("inlineCode",{parentName:"p"},"Object3D")," that is constrained in the Physic World. However, we're not actually rendering it to the scene as we do not associate it with any 3D representation. That allows us to still create ",(0,i.kt)("a",{parentName:"p",href:"./constraint"},"constraint")," between the ",(0,i.kt)("inlineCode",{parentName:"p"},"fixture")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"lamp"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"use on template example",src:n(6413).Z,width:"1382",height:"1114"})),(0,i.kt)("p",null,"In this image, the lamp is constrained with the fixture which is ",(0,i.kt)("strong",{parentName:"p"},"fixed")," to the top."),(0,i.kt)("h2",{id:"ref"},(0,i.kt)("inlineCode",{parentName:"h2"},"ref")),(0,i.kt)("p",null,"All body creators accept an optional 3rd argument ",(0,i.kt)("inlineCode",{parentName:"p"},"ref"),". This argument allows us to pass in an existed ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref"),". By default, ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtPhysicBody")," creates a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," then expects us to pass this ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"NgtObject"),"."),(0,i.kt)("p",null,"However, there are cases where we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," that is intracting with many different objects on the 3D scene. One such case is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Sphere"),' representing our mouse on the scene so we can apply physic to our "Mouse".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nconst cursor = new Ref<THREE.Object3D>();\n// highlight-end\n\n@Component({\n  providers: [NgtPhysicBody],\n})\nexport class CursorComponent {\n  sphereRef = this.physicBody.useSphere(\n    () => ({\n      /*...*/\n    }),\n    true,\n    // highlight-start\n    cursor\n    // highlight-end\n  );\n\n  constructor(private physicBody: NgtPhysicBody) {}\n}\n")),(0,i.kt)("h2",{id:"types"},"Types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass."),(0,i.kt)("li",{parentName:"ul"},"A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies."),(0,i.kt)("li",{parentName:"ul"},"A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.")))}h.isMDXComponent=!0},6413:function(e,t,n){t.Z=n.p+"assets/images/use-on-template-example-96d72059d5dab5c9fe6a84423e3ed2c7.png"}}]);